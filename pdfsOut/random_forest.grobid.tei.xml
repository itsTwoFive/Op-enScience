<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Random Forests</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Leo</forename><surname>Breiman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
						</author>
						<title level="a" type="main">Random Forests</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">87FE0F6AA567548192A015A1C8473C99</idno>
					<note type="submission">Received November 30, 1999 Revised April 11, 2001 Accepted April 11, 2001 Final manuscript April 11, 2001</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1-SNAPSHOT" ident="GROBID" when="2024-03-04T20:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>classification</term>
					<term>regression</term>
					<term>ensemble 1. Random forests</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Random forests are a combination of tree predictors such that each tree depends on the values of a random vector sampled independently and with the same distribution for all trees in the forest. The generalization error for forests converges a.s. to a limit as the number of trees in the forest becomes large. The generalization error of a forest of tree classifiers depends on the strength of the individual trees in the forest and the correlation between them. Using a random selection of features to split each node yields error rates that compare favorably to Adaboost (Y. Freund &amp; R. Schapire, Machine Learning: Proceedings of the Thirteenth International conference, * * * , 148-156), but are more robust with respect to noise. Internal estimates monitor error, strength, and correlation and these are used to show the response to increasing the number of features used in the splitting. Internal estimates are also used to measure variable importance. These ideas are also applicable to regression.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Introduction</head><p>Significant improvements in classification accuracy have resulted from growing an ensemble of trees and letting them vote for the most popular class. In order to grow these ensembles, often random vectors are generated that govern the growth of each tree in the ensemble. An early example is bagging <ref type="bibr" target="#b3">(Breiman, 1996)</ref>, where to grow each tree a random selection (without replacement) is made from the examples in the training set.</p><p>Another example is random split selection <ref type="bibr" target="#b9">(Dietterich, 1998)</ref> where at each node the split is selected at random from among the K best splits. <ref type="bibr" target="#b7">Breiman (1999)</ref> generates new training sets by randomizing the outputs in the original training set. Another approach is to select the training set from a random set of weights on the examples in the training set. <ref type="bibr" target="#b12">Ho (1998)</ref> has written a number of papers on "the random subspace" method which does a random selection of a subset of features to use to grow each tree.</p><p>In an important paper on written character recognition, <ref type="bibr" target="#b0">Amit and Geman (1997)</ref> define a large number of geometric features and search over a random selection of these for the best split at each node. This latter paper has been influential in my thinking.</p><p>The common element in all of these procedures is that for the kth tree, a random vector k is generated, independent of the past random vectors 1,..., k-1 but with the same distribution; and a tree is grown using the training set and k , resulting in a classifier h(x, k ) where x is an input vector. For instance, in bagging the random vector is generated as the counts in N boxes resulting from N darts thrown at random at the boxes, where N is number of examples in the training set. In random split selection consists of a number of independent random integers between 1 and K . The nature and dimensionality of depends on its use in tree construction.</p><p>After a large number of trees is generated, they vote for the most popular class. We call these procedures random forests.</p><p>Definition 1.1. A random forest is a classifier consisting of a collection of tree-structured classifiers {h(x, k ), k = 1, . . .} where the { k } are independent identically distributed random vectors and each tree casts a unit vote for the most popular class at input x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Outline of paper</head><p>Section 2 gives some theoretical background for random forests. Use of the Strong Law of Large Numbers shows that they always converge so that overfitting is not a problem. We give a simplified and extended version of the <ref type="bibr" target="#b0">Amit and Geman (1997)</ref> analysis to show that the accuracy of a random forest depends on the strength of the individual tree classifiers and a measure of the dependence between them (see Section 2 for definitions).</p><p>Section 3 introduces forests using the random selection of features at each node to determine the split. An important question is how many features to select at each node. For guidance, internal estimates of the generalization error, classifier strength and dependence are computed. These are called out-of-bag estimates and are reviewed in Section 4. Section 5 and 6 give empirical results for two different forms of random features. The first uses random selection from the original inputs; the second uses random linear combinations of inputs. The results compare favorably to Adaboost.</p><p>The results turn out to be insensitive to the number of features selected to split each node. Usually, selecting one or two features gives near optimum results. To explore this and relate it to strength and correlation, an empirical study is carried out in Section 7.</p><p>Adaboost has no random elements and grows an ensemble of trees by successive reweightings of the training set where the current weights depend on the past history of the ensemble formation. But just as a deterministic random number generator can give a good imitation of randomness, my belief is that in its later stages Adaboost is emulating a random forest. Evidence for this conjecture is given in Section 8.</p><p>Important recent problems, i.e., medical diagnosis and document retrieval, often have the property that there are many input variables, often in the hundreds or thousands, with each one containing only a small amount of information. A single tree classifier will then have accuracy only slightly better than a random choice of class. But combining trees grown using random features can produce improved accuracy. In Section 9 we experiment on a simulated data set with 1,000 input variables, 1,000 examples in the training set and a 4,000 example test set. Accuracy comparable to the Bayes rate is achieved.</p><p>In many applications, understanding of the mechanism of the random forest "black box" is needed. Section 10 makes a start on this by computing internal estimates of variable importance and binding these together by reuse runs.</p><p>Section 11 looks at random forests for regression. A bound for the mean squared generalization error is derived that shows that the decrease in error from the individual trees in the forest depends on the correlation between residuals and the mean squared error of the individual trees. Empirical results for regression are in Section 12. Concluding remarks are given in Section 13.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Characterizing the accuracy of random forests</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Random forests converge</head><p>Given an ensemble of classifiers h 1 (x), h 2 (x), . . . , h K (x), and with the training set drawn at random from the distribution of the random vector Y, X, define the margin function as</p><formula xml:id="formula_0">mg(X, Y ) = av k I (h k (X) = Y ) -max j =Y av k I (h k (X) = j).</formula><p>where I (•) is the indicator function. The margin measures the extent to which the average number of votes at X, Y for the right class exceeds the average vote for any other class. The larger the margin, the more confidence in the classification. The generalization error is given by</p><formula xml:id="formula_1">PE * = P X,Y (mg(X, Y ) &lt; 0)</formula><p>where the subscripts X, Y indicate that the probability is over the X, Y space.</p><p>In random forests, h k (X) = h(X, k ). For a large number of trees, it follows from the Strong Law of Large Numbers and the tree structure that: Theorem 1.2. As the number of trees increases, for almost surely all sequences 1,... PE * converges to</p><formula xml:id="formula_2">P X,Y (P (h(X, ) = Y ) -max j =Y P (h(X, ) = j) &lt; 0).</formula><p>(1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof: see Appendix I. ✷</head><p>This result explains why random forests do not overfit as more trees are added, but produce a limiting value of the generalization error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Strength and correlation</head><p>For random forests, an upper bound can be derived for the generalization error in terms of two parameters that are measures of how accurate the individual classifiers are and of the dependence between them. The interplay between these two gives the foundation for understanding the workings of random forests. We build on the analysis in <ref type="bibr" target="#b0">Amit and Geman (1997)</ref>.</p><p>Definition 2.1. The margin function for a random forest is</p><formula xml:id="formula_3">mr(X, Y ) = P (h(X, ) = Y ) -max j =Y P (h(X, ) = j) (2)</formula><p>and the strength of the set of classifiers {h(x, )} is</p><formula xml:id="formula_4">s = E X,Y mr(X, Y ). (<label>3</label></formula><formula xml:id="formula_5">)</formula><p>Assuming s ≥ 0, Chebychev's inequality gives</p><formula xml:id="formula_6">PE * ≤ var(mr)/s 2<label>(4)</label></formula><p>A more revealing expression for the variance of mr is derived in the following: Let</p><formula xml:id="formula_7">ĵ(X, Y ) = arg max j =Y P (h(X, ) = j) so mr(X, Y ) = P (h(X, ) = Y ) -P (h(X, ) = ĵ(X, Y )) = E [I (h(X, ) = Y ) -I (h(X, ) = ĵ(X, Y )].</formula><p>Definition 2.2. The raw margin function is</p><formula xml:id="formula_8">rmg( , X, Y ) = I (h(X, ) = Y ) -I (h(X, ) = ĵ(X, Y )).</formula><p>Thus, mr(X, Y ) is the expectation of rmg( , X, Y ) with respect to . For any function f the identity</p><formula xml:id="formula_9">[E f ( )] 2 = E , f ( ) f ( )</formula><p>holds where , are independent with the same distribution, implying that</p><formula xml:id="formula_10">mr(X, Y ) 2 = E , rmg( , X, Y )rmg( , X, Y ) (5) Using (5) gives var(mr) = E , (cov X,Y rmg( , X, Y )rmg( , X, Y )) = E , (ρ( , )sd( )sd( )) (6)</formula><p>where ρ( , ) is the correlation between rmg( , X, Y ) and rmg( , X, Y ) holding , fixed and sd( ) is the standard deviation of rmg( , X, Y ) holding fixed. Then,</p><formula xml:id="formula_11">var(mr) = ρ(E sd( )) 2 ≤ ρ E var( ) (<label>7</label></formula><formula xml:id="formula_12">)</formula><p>where ρ is the mean value of the correlation; that is,</p><formula xml:id="formula_13">ρ = E , (ρ( , )sd( )sd( ))/E , (sd( )sd( )) Write E var( ) ≤ E (E X,Y rmg( , X, Y )) 2 -s 2 ≤ 1 -s 2 . (<label>8</label></formula><formula xml:id="formula_14">)</formula><p>Putting ( <ref type="formula" target="#formula_6">4</ref>), ( <ref type="formula" target="#formula_11">7</ref>), and (8) together yields:</p><p>Theorem 2.3. An upper bound for the generalization error is given by</p><formula xml:id="formula_15">PE * ≤ ρ(1 -s 2 )/s 2 .</formula><p>Although the bound is likely to be loose, it fulfills the same suggestive function for random forests as VC-type bounds do for other types of classifiers. It shows that the two ingredients involved in the generalization error for random forests are the strength of the individual classifiers in the forest, and the correlation between them in terms of the raw margin functions. The c/s2 ratio is the correlation divided by the square of the strength. In understanding the functioning of random forests, this ratio will be a helpful guide-the smaller it is, the better.</p><p>Definition 2.4. The c/s2 ratio for a random forest is defined as</p><formula xml:id="formula_16">c/s2 = ρ/s 2 .</formula><p>There are simplifications in the two class situation. The margin function is</p><formula xml:id="formula_17">mr(X, Y ) = 2P (h(X, ) = Y ) -1</formula><p>The requirement that the strength is positive (see (4)) becomes similar to the familiar weak learning condition E X,Y P (h(X, ) = Y )&gt;.5. The raw margin function is 2I (h(X, ) = Y )-1 and the correlation ρ is between I (h(X, ) = Y ) and I (h(X, ) = Y ). In particular, if the values for Y are taken to be +1 and -1, then</p><formula xml:id="formula_18">ρ = E , [ρ(h(•, ), h(•, )]</formula><p>so that ρ is the correlation between two different members of the forest averaged over the , distribution.</p><p>For more than two classes, the measure of strength defined in (3) depends on the forest as well as the individual trees since it is the forest that determines ĵ(X, Y ). Another approach L. BREIMAN is possible. Write</p><formula xml:id="formula_19">PE * = P X,Y (P (h(X, ) = Y ) -max j =Y P (h(X, ) = j) &lt; 0) ≤ j P X,Y (P (h(X, ) = Y ) -P (h(X, ) = j) &lt; 0). Define s j = E X,Y (P (h(X, ) = Y ) -P (h(X, ) = j))</formula><p>to be the strength of the set of classifiers {h(x, )} relative to class j. Note that this definition of strength does not depend on the forest. Using Chebyshev's inequality, assuming all s j&gt;0 leads to</p><formula xml:id="formula_20">PE * ≤ j var(P (h(X, ) = Y ) -P (h(X, ) = j))s 2 j (9)</formula><p>and using identities similar to those used in deriving (7), the variances in (9) can be expressed in terms of average correlations. I did not use estimates of the quantities in (9) in our empirical study but think they would be interesting in a multiple class problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Using random features</head><p>Some random forests reported in the literature have consistently lower generalization error than others. For instance, random split selection <ref type="bibr">(Dieterrich, 1998)</ref> does better than bagging. Breiman's introduction of random noise into the outputs <ref type="bibr">(Breiman, 1998c</ref>) also does better. But none of these these three forests do as well as Adaboost <ref type="bibr" target="#b10">(Freund &amp; Schapire, 1996)</ref> or other algorithms that work by adaptive reweighting (arcing) of the training set (see <ref type="bibr" target="#b6">Breiman, 1998b;</ref><ref type="bibr">Dieterrich, 1998;</ref><ref type="bibr" target="#b2">Bauer &amp; Kohavi, 1999)</ref>.</p><p>To improve accuracy, the randomness injected has to minimize the correlation ρ while maintaining strength. The forests studied here consist of using randomly selected inputs or combinations of inputs at each node to grow each tree. The resulting forests give accuracy that compare favorably with Adaboost. This class of procedures has desirable characteristics: i Its accuracy is as good as Adaboost and sometimes better. ii It's relatively robust to outliers and noise. iii It's faster than bagging or boosting. iv It gives useful internal estimates of error, strength, correlation and variable importance. v It's simple and easily parallelized. <ref type="bibr" target="#b0">Amit and Geman (1997)</ref> grew shallow trees for handwritten character recognition using random selection from a large number of geometrically defined features to define the split at each node. Although my implementation is different and not problem specific, it was their work that provided the start for my ideas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Using out-of-bag estimates to monitor error, strength, and correlation</head><p>In my experiments with random forests, bagging is used in tandem with random feature selection. Each new training set is drawn, with replacement, from the original training set. Then a tree is grown on the new training set using random feature selection. The trees grown are not pruned.</p><p>There are two reasons for using bagging. The first is that the use of bagging seems to enhance accuracy when random features are used. The second is that bagging can be used to give ongoing estimates of the generalization error (PE * ) of the combined ensemble of trees, as well as estimates for the strength and correlation. These estimates are done out-of-bag, which is explained as follows.</p><p>Assume a method for constructing a classifier from any training set. Given a specific training set T , form boostrap training sets T k , construct classifiers h(x, T k ) and let these vote to form the bagged predictor. For each y, x in the training set, aggregate the votes only over those classifiers for which T k does not containing y, x. Call this the out-of-bag classifier. Then the out-of-bag estimate for the generalization error is the error rate of the out-of-bag classifier on the training set. <ref type="bibr" target="#b15">Tibshirani (1996)</ref> and <ref type="bibr">Wolpert and Macready (1996)</ref>, proposed using out-of-bag estimates as an ingredient in estimates of generalization error. Wolpert and Macready worked on regression type problems and proposed a number of methods for estimating the generalization error of bagged predictors. Tibshirani used out-of-bag estimates of variance to estimate generalization error for arbitrary classifiers. The study of error estimates for bagged classifiers in <ref type="bibr" target="#b4">Breiman (1996b)</ref>, gives empirical evidence to show that the outof-bag estimate is as accurate as using a test set of the same size as the training set. Therefore, using the out-of-bag error estimate removes the need for a set aside test set.</p><p>In each bootstrap training set, about one-third of the instances are left out. Therefore, the out-of-bag estimates are based on combining only about one-third as many classifiers as in the ongoing main combination. Since the error rate decreases as the number of combinations increases, the out-of-bag estimates will tend to overestimate the current error rate. To get unbiased out-of-bag estimates, it is necessary to run past the point where the test set error converges. But unlike cross-validation, where bias is present but its extent unknown, the out-of-bag estimates are unbiased.</p><p>Strength and correlation can also be estimated using out-of-bag methods. This gives internal estimates that are helpful in understanding classification accuracy and how to improve it. The details are given in Appendix II. Another application is to the measures of variable importance (see Section 10).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Random forests using random input selection</head><p>The simplest random forest with random features is formed by selecting at random, at each node, a small group of input variables to split on. Grow the tree using CART methodology to maximum size and do not prune. Denote this procedure by Forest-RI. The size F of the group is fixed. Two values of F were tried. The first used only one randomly selected variable, i.e., F = 1. The second took F to be the first integer less than log 2 M + 1, where M is the number of inputs. My experiments use 13 smaller sized data sets from the UCI repository, 3 larger sets separated into training and test sets and 4 synthetic data sets. The first 10 sets were selected because I had used them in past research. Table <ref type="table" target="#tab_0">1</ref> gives a brief summary.</p><p>On each of the 13 smaller sized data sets, the following procedure was used: a random 10% of the data was set aside. On the remaining data, random forest was run twice, growing and combining 100 trees-once with F = 1, and the second time with F = int(log 2 M +1). The set aside 10% was then put down each forest to get a test set error for both. The test set error selected corresponded to the lower value of the out-of-bag estimate in the two runs. This was repeated 100 times and the test set errors averaged. The same procedure was followed for the Adaboost runs which are based on combining 50 trees.</p><p>The use for 100 trees in random forests and 50 for Adaboost comes from two sources. The out-of-bag estimates are based on only about a third as many trees as are in the forest. To get reliable estimates I opted for 100 trees. The second consideration is that growing random forests is many times faster than growing the trees based on all inputs needed in Adaboost. Growing the 100 trees in random forests was considerably quicker than the 50 trees for Adaboost. In the runs on the larger data sets, the random forest results for the first two data sets were based on combining 100 trees; the zip-code procedure combined 200. For Adaboost, 50 trees were combined for the first three data sets and 100 for zip-code. The synthetic data was described in <ref type="bibr" target="#b3">Breiman (1996)</ref> and also used in <ref type="bibr">Schapire et al. (1997)</ref>. There were 50 runs. In each run, a new training set of size 300 and test set of size 3000 were generated. In random forests 100 trees were combined in each run-50 in Adaboost. The results of these runs are given in Table <ref type="table" target="#tab_1">2</ref>.</p><p>The second column are the results selected from the two group sizes by means of lowest out-of-bag error. The third column is the test set error using just one random feature to grow the trees. The fourth column contains the out-of-bag estimates of the generalization error of the individual trees in the forest computed for the best setting (single or selection). This estimate is computed by using the left-out instances as a test set in each tree grown and averaging the result over all trees in the forest.</p><p>The error rates using random input selection compare favorably with Adaboost. The comparison might be even more favorable if the search is over more values of F instead of the preset two. But the procedure is not overly sensitive to the value of F. The average absolute difference between the error rate using F = 1 and the higher value of F is less than 1%. The difference is most pronounced on the three large data sets.</p><p>The single variable test set results were included because in some of the data sets, using a single random input variable did better than using several. In the others, results were only slightly better than use of a single variable. It was surprising that using a single randomly chosen input variable to split on at each node could produce good accuracy.</p><p>Random input selection can be much faster than either Adaboost or Bagging. A simple analysis shows that the ratio of RI compute time to the compute time of unpruned tree construction using all variables is F * log 2 (N )/M where F is the number of variables used in Forest-RI, N is the number of instances, and M the number of input variables. For zipcode data, using F = 1, the ratio is .025, implying that Forest-RI is 40 times faster. An empirical check confirmed this difference. A Forest-RI run (F = 1) on the zip-code data takes 4.0 minutes on a 250 Mhz Macintosh to generate 100 trees compared to almost three hours for Adaboost. For data sets with many variables, the compute time difference may be significant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Random forests using linear combinations of inputs</head><p>If there are only a few inputs, say M, taking F an appreciable fraction of M might lead an increase in strength but higher correlation. Another approach consists of defining more features by taking random linear combinations of a number of the input variables. That is, a feature is generated by specifying L, the number of variables to be combined. At a given node, L variables are randomly selected and added together with coefficients that are uniform random numbers on [-1, 1]. F linear combinations are generated, and then a search is made over these for the best split. This procedure is called Forest-RC.</p><p>We use L = 3 and F = 2, 8 with the choice for F being decided on by the out-ofbag estimate. We selected L = 3 because with O(M 3 ) different combinations of the input variables, larger values of F should not cause much of a rise in correlation while increasing strength. If the input variables in a data set are incommensurable, they are normalized by subtracting means and dividing by standard deviations, where the means and standard deviations are determined from the training set. The test set results are given in Table <ref type="table" target="#tab_2">3</ref> where the third column contains the results for F = 2. The fourth column contains the results for individual trees computed as for Table <ref type="table" target="#tab_1">2</ref>.</p><p>Except for the three larger data sets, use of F = 8 is superflous; F = 2 achieves close to the minimum. On the larger data sets, F = 8 gives better results. Forest-RC does exceptionally well on the synthetic data sets. Overall, it compares more favorably to Adaboost than Forest-RI.</p><p>In Tables <ref type="table" target="#tab_1">2</ref> and<ref type="table" target="#tab_2">3</ref> there are some entries for which the selected entry is less than the one input value or with Forest-RC, less than the two-feature value. The reason this happens is that when the error rates corresponding to the two values of F are close together, then the out-of-bag estimates will select a value of F almost at random.</p><p>A small investigation was carried out to see if performance on the three larger data sets could be improved. Based on the runs with the satellite data in Section 6, we conjectured that the strength keeps rising in the larger data sets while the correlation reaches an asymptote more quickly. Therefore we did some runs with F = 100 on the larger data sets using 100, 100 and 200 trees in the three forests respectively. On the satellite data, the error dropped to 8.5%, on the letters data to 3.0%, but the zip-code test set error did not decrease. Acting on an informed hunch, I tried Forest-RI with F = 25. The zip-code test set error dropped to 5.8%. These are the lowest test set errors so far achieved on these three data sets by tree ensembles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Categorical variables</head><p>Some or all of the input variables may be categoricals and since we want to define additive combinations of variables, we need to define how categoricals will be treated so they can be combined with numerical variables. My approach is that each time a categorical variable is selected to split on at a node, to select a random subset of the categories of the variable, and define a substitute variable that is one when the categorical value of the variable is in the subset and zero outside. Since a categorical variable with I values can be coded into I -1 dummy 0-1 variables, we make the variable I -1 times as probable as a numeric variable to be selected in node splitting. When many of the variables are categorical, using a low value of F results in low correlation, but also low strength. F must be increased to about two-three times int(log 2 M + 1) to get enough strength to provide good test set accuracy.</p><p>For instance, on the DNA data set having 60 four-valued categorical values, 2,000 examples in the training set and 1,186 in the test set, using Forest-RI with F = 20 gave a test set error rate of 3.6% (4.2% for Adaboost). The soybean data has 685 examples, 35 variables, 19 classes, and 15 categorical variables. Using Forest-RI with F = 12 gives a test set error of 5.3% (5.8% for Adaboost). Using Forest-RC with combinations of 3 and F = 8 gives an error of 5.5%.</p><p>One advantage of this approach is that it gets around the difficulty of what to do with categoricals that have many values. In the two-class problem, this can be avoided by using the device proposed in <ref type="bibr">Breiman et al. (1985)</ref> which reduces the search for the best categorical split to an O(I ) computation. For more classes, the search for the best categorical split is an O(2 I -1 ) computation. In the random forest implementation, the computation for any categorical variable involves only the selection of a random subset of the categories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Empirical results on strength and correlation</head><p>The purpose of this section is to look at the effect of strength and correlation on the generalization error. Another aspect that we wanted to get more understanding of was the lack of sensitivity in the generalization error to the group size F. To conduct an empirical study of the effects of strength and correlation in a variety of data sets, out-of-bag estimates of the strength and correlation, as described in Section 3.1, were used.</p><p>We begin by running Forest-RI on the sonar data (60 inputs, 208 examples) using from 1 to 50 inputs. In each iteration, 10% of the data was split off as a test set. Then F, the number of random inputs selected at each node, was varied from 1 to 50. For each value of F, 100 trees were grown to form a random forest and the terminal values of test set error, strength, correlation, etc. recorded. Eighty iterations were done, each time removing a random 10% of the data for use as a test set, and all results averaged over the 80 repetitions. Altogether, 400,000 trees were grown in this experiment.</p><p>The top graph of figure <ref type="figure" target="#fig_0">1</ref>, plots the values of strength and correlation vs. F. The result is fascinating. Past about F = 4 the strength remains constant; adding more inputs does not help. But the correlation continues to increase. The second graph plots the test set errors and the out-of-bag estimates of the generalization error against F. The out-of-bag estimates are more stable. Both show the same behavior-a small drop from F = 1 out to F about 4-8, and then a general, gradual increase. This increase in error tallies with the beginning of the constancy region for the strength.</p><p>Figure <ref type="figure">2</ref> has plots for similar runs on the breast data set where features consisting of random combinations of three inputs are used. The number of these features was varied from 1 to 25. Again, the correlation shows a slow rise, while the strength stays virtually constant, so that the minimum error is at F = 1. The surprise in these two figures is the relative constancy of the strength. Since the correlations are slowly but steadily increasing, the lowest error occurs when only a few inputs or features are used.</p><p>Since the larger data sets seemed to have a different behavior than the smaller, we ran a similar experiment on the satellite data set. The number of features, each consisting of a random sum of two inputs, was varied from 1 to 25, and for each, 100 classifiers were combined. The results are shown in figure <ref type="figure" target="#fig_1">3</ref>. The results differ from those on the smaller  data sets. Both the correlation and strength show a small but steady increase. The error rates show a slight decrease. We conjecture that with larger and more complex data sets, the strength continues to increase longer before it plateaus out.</p><p>Our results indicate that better (lower generalization error) random forests have lower correlation between classifiers and higher strength. The randomness used in tree construction has to aim for low correlation ρ while maintaining reasonable strength. This conclusion has been hinted at in previous work. <ref type="bibr" target="#b9">Dietterich (1998)</ref> has measures of dispersion of an ensemble and notes that more accurate ensembles have larger dispersion. Freund (personal communication) believes that one reason why Adaboost works so well is that at each step it tries to decouple the next classifier from the current one. <ref type="bibr" target="#b1">Amit et al. (1999)</ref> give an analysis to show that the Adaboost algorithm is aimed at keeping the covariance between classifiers small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conjecture: Adaboost is a random forest</head><p>Various classifiers can be modified to use both a training set and a set of weights on the training set. Consider the following random forest: a large collection of K different sets of non-negative sum-one weights on the training set is defined. Denote these weights by w(1), w(2), . . . , w(K ). Corresponding to these weights are probabilities p(1), p(2), . . . , p(K) whose sum is one. Draw from the integers 1, . . . , K according to these probabilities. The outcome is . If = k grow the classifier h(x, ) using the training set with weights w(k).</p><p>In its original version, Adaboost <ref type="bibr" target="#b10">(Freund &amp; Schapire, 1996)</ref> is a deterministic algorithm that selects the weights on the training set for input to the next classifier based on the misclassifications in the previous classifiers. In our experiment, random forests were produced as follows: Adaboost was run 75 times on a data set producing sets of non-negative sum-one weights w(1), w(2), . . . , w(50) (the first 25 were discarded). The probability for the kth set of weights is set proportional to Q(w k ) = log[(1error(k))/error(k)] where error(k) is the w(k) weighted training set error of the kth classifier. Then the forest is run 250 times.</p><p>This was repeated 100 times on a few data sets, each time leaving out 10% as a test set and then averaging the test set errors. On each data set, the Adaboost error rate was very close to the random forest error rate. A typical result is on the Wisconsin Breast Cancer data where Adaboost produced an average of 2.91% error and the random forest produced 2.94%.</p><p>In the Adaboost algorithm, w(k + 1) = φ(w(k)) where φ is a function determined by the base classifier. Denote the kth classifier by h(x, w k ). The vote of the kth classifier is weighted by Q(w k ) so the normalized vote for class j at x equals</p><formula xml:id="formula_21">k I (h(x, w k ) = j)Q(w k ) k Q(w k ). (<label>10</label></formula><formula xml:id="formula_22">)</formula><p>For any function f defined on the weight space, define the operator T f (w) = f (φ(w)).</p><p>We conjecture that T is ergodic with invariant measure π(dw). Then (10) will converge to</p><formula xml:id="formula_23">E Qπ [I (h(x, w) = j)] where the distribution Qπ(dw) = Q(w)π(dw)/ Q(v)π(dv).</formula><p>If this conjecture is true, then Adaboost is equivalent to a random forest where the weights on the training set are selected at random from the distribution Qπ.</p><p>Its truth would also explain why Adaboost does not overfit as more trees are added to the ensemble-an experimental fact that has been puzzling. There is some experimental evidence that Adaboost may overfit if run thousands of times <ref type="bibr" target="#b11">(Grove &amp; Schuurmans, 1998)</ref>, but these runs were done using a very simple base classifier and may not carry over to the use of trees as the base classifiers. My experience running Adaboost out to 1,0000 trees on a number of data sets is that the test set error converges to an asymptotic value.</p><p>The truth of this conjecture does not solve the problem of how Adaboost selects the favorable distributions on the weight space that it does. Note that the distribution of the weights will depend on the training set. In the usual random forest, the distribution of the random vectors does not depend on the training set. <ref type="bibr" target="#b9">Dietterich (1998)</ref> showed that when a fraction of the output labels in the training set are randomly altered, the accuracy of Adaboost degenerates, while bagging and random split selection are more immune to the noise. Since some noise in the outputs is often present, robustness with respect to noise is a desirable property. Following Dietterich (1998) the following experiment was done which changed about one in twenty class labels (injecting 5% noise).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">The effects of output noise</head><p>For each data set in the experiment, 10% at random is split off as a test set. Two runs are made on the remaining training set. The first run is on the training set as is. The second run is on a noisy version of the training set. The noisy version is gotten by changing, at random, 5% of the class labels into an alternate class label chosen uniformly from the other labels. This is repeated 50 times using Adaboost (deterministic version), Forest-RI and Forest-RC. The test set results are averaged over the 50 repetitions and the percent increase due to the noise computed. In both random forests, we used the number of features giving the lowest test set error in the Section 5 and 6 experiments. Because of the lengths of the runs, only the 9 smallest data sets are used. Table <ref type="table" target="#tab_3">4</ref> gives the increases in error rates due to the noise. Adaboost deteriorates markedly with 5% noise, while the random forest procedures generally show small changes. The effect on Adaboost is curiously data set dependent, with the two multiclass data sets, glass and ecoli, along with diabetes, least effected by the noise. The Adaboost algorithm iteratively increases the weights on the instances most recently misclassified. Instances having incorrect class labels will persist in being misclassified. Then, Adaboost will concentrate increasing weight on these noisy instances and become warped. The random forest procedures do not concentrate weight on any subset of the instances and the noise effect is smaller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Data with many weak inputs</head><p>Data sets with many weak inputs are becoming more common, i.e. in medical diagnosis, document retrieval, etc. The common characteristics is no single input or small group of inputs can distinguish between the classes. This type of data is difficult for the usual classifiers-neural nets and trees.</p><p>To see if there is a possibility that Forest-RI methods can work, the following 10 class, 1,000 binary input data, was generated: (rnd is a uniform random number, selected anew each time it appears) do j=1,10 do k=1,1000 p(j,k)=.2 * rnd+.01 end do end do do j=1,10 do i=1, nint(400 * rnd) !nint=nearest integer k=nint(1000 * rnd) p(j,k)=p(j,k)+.4 * rnd end do end do</p><formula xml:id="formula_24">do n=1,N j=nint(10 * rnd) do m=1,1000 if (rnd&lt;p(j,m) )then x(m,n)=1 else x(m,n)=0 end if y(n)=j ! y(n)</formula><p>is the class label of the nth example end do end do This code generates a set of probabilities {p(j, m)} where j is the class label and m is the input number. Then the inputs for a class j example are a string of M binary variables with the mth variable having probability p(j, m) of being one.</p><p>For the training set, N = 1,000. A 4,000 example test set was also constructed using the same {p (j, k)}. Examination of the code shows that each class has higher underlying probability at certain locations. But the total over all classes of these locations is about 2,000, so there is significant overlap. Assuming one knows all of the {p (j, k)}, the Bayes error rate for the particular {p (j, m)} computed in our run is 1.0%.</p><p>Since the inputs are independent of each other, the Naive Bayes classifier, which estimates the {p (j,k)} from the training data is supposedly optimal and has an error rate of 6.2%. This is not an endorsement of Naive Bayes, since it would be easy to create a dependence between the inputs which would increase the Naive Bayes error rate. I stayed with this example because the Bayes error rate and the Naive Bayes error rate are easy to compute.</p><p>I started with a run of Forest-RI with F = 1. It converged very slowly and by 2,500 iterations, when it was stopped, it had still not converged. The test set error was 10.7%. The strength was .069 and the correlation .012 with a c/s2 ratio of 2.5. Even though the strength was low, the almost zero correlation meant that we were adding small increments of accuracy as the iterations proceeded.</p><p>Clearly, what was desired was an increase in strength while keeping the correlation low. Forest-RI was run again using F = int(log 2 M + 1) = 10. The results were encouraging. It converged after 2,000 iterations. The test set error was 3.0%. The strength was .22, the correlation .045 and c/s2 = .91. Going with the trend, Forest-RI was run with F = 25 and stopped after 2,000 iterations. The test set error was 2.8%. Strength was .28, correlation .065 and c/s2 = .83.</p><p>It's interesting that Forest-RI could produce error rates not far above the Bayes error rate. The individual classifiers are weak. For F = 1, the average tree error rate is 80%; for F = 10, it is 65%; and for F = 25, it is 60%. Forests seem to have the ability to work with very weak classifiers as long as their correlation is low. A comparison using Adaboost was tried, but I can't get Adaboost to run on this data because the base classifiers are too weak.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Exploring the random forest mechanism</head><p>A forest of trees is impenetrable as far as simple interpretations of its mechanism go. In some applications, analysis of medical experiments for example, it is critical to understand the interaction of variables that is providing the predictive accuracy. A start on this problem is made by using internal out-of-bag estimates, and verification by reruns using only selected variables.</p><p>Suppose there are M input variables. After each tree is constructed, the values of the mth variable in the out-of-bag examples are randomly permuted and the out-of-bag data is run down the corresponding tree. The classification given for each x n that is out of bag is saved. This is repeated for m = 1, 2, . . . , M. At the end of the run, the plurality of out-of-bag class votes for x n with the mth variable noised up is compared with the true class label of x n to give a misclassification rate. The output is the percent increase in misclassification rate as compared to the out-of-bag rate (with all variables intact). We get these estimates by using a single run of a forest with 1,000 trees and no test set. The procedure is illustrated by examples.</p><p>In the diabetes data set, using only single variables with F = 1, the rise in error due to the noising of variables is given in figure <ref type="figure" target="#fig_2">4</ref> The second variable appears by far the most important followed by variable 8 and variable 6. Running the random forest in 100 repetitions using only variable 2 and leaving out 10% each time to measure test set error gave an error of 29.7%, compared with 23.1% using all variables. But when variable 8 is added, the error falls only to 29.4%. When variable 6 is added to variable 2, the error falls to 26.4%.</p><p>The reason that variable 6 seems important, yet is no help once variable 2 is entered is a characteristic of how dependent variables affect prediction error in random forests. Say there are two variables x 1 and x 2 which are identical and carry significant predictive information. Because each gets picked with about the same frequency in a random forest, noising each separately will result in the same increase in error rate. But once x 1 is entered as a predictive variable, using x 2 in addition will not produce any decrease in error rate. In the diabetes data set, the 8th variable carries some of the same information as the second. So it does not add predictive accuracy when combined with the second.</p><p>The relative magnitudes of rises in error rates are fairly stable with respect to the input features used. The experiment above was repeated using combinations of three inputs with F = 2. The results are in figure <ref type="figure" target="#fig_3">5</ref>.</p><p>Another interesting example is the voting data. This has 435 examples corresponding to 435 Congressmen and 16 variables reflecting their yes-no votes on 16 issues. The class variable is Republican or Democrat. To see which issues were most important, we again ran the noising variables program generating 1,000 trees. The lowest error rate on the original data was gotten using single inputs with F = 5, so these parameters were used in the run. The results in figure <ref type="figure" target="#fig_4">6</ref>.</p><p>Variable 4 stands out-the error triples if variable 4 is noised. We reran this data set using only variable 4. The test set error is 4.3%, about the same as if all variables were used. The  The approach given in this section is only a beginning. More research will be necessary to understand how to give a more complete picture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Random forests for regression</head><p>Random forests for regression are formed by growing trees depending on a random vector such that the tree predictor h(x, ) takes on numerical values as opposed to class labels. The output values are numerical and we assume that the training set is independently drawn from the distribution of the random vector Y, X. The mean-squared generalization error for any numerical predictor h(x) is</p><formula xml:id="formula_25">E X,Y (Y -h(X)) 2 (11)</formula><p>The random forest predictor is formed by taking the average over k of the trees {h(x, k )}.</p><p>Similarly to the classification case, the following holds:</p><p>Theorem 11.1. As the number of trees in the forest goes to infinity, almost surrely,</p><formula xml:id="formula_26">E X,Y (Y -av k h(X, k )) 2 → E X,Y (Y -E h(X, )) 2 . (<label>12</label></formula><formula xml:id="formula_27">)</formula><p>Proof: see Appendix I. ✷</p><p>Denote the right hand side of ( <ref type="formula" target="#formula_26">12</ref>) as PE * (forest)-the generalization error of the forest. Define the average generalization error of a tree as:</p><formula xml:id="formula_28">PE * (tree) = E E X,Y (Y -h(X, )) 2 Theorem 11.2. Assume that for all , EY = E X h(X, ). Then PE * ( forest) ≤ ρPE * (tree)</formula><p>where ρ is the weighted correlation between the residuals Yh(X, ) and Yh(X, ) where , are independent.</p><p>Proof:</p><formula xml:id="formula_29">PE * ( forest) = E X,Y [E (Y -h(X, )] 2 = E E E X,Y (Y -h(X, ))(Y -h(X, ))<label>(13)</label></formula><p>The term on the right in ( <ref type="formula" target="#formula_29">13</ref>) is a covariance and can be written as:</p><formula xml:id="formula_30">E E (ρ( , )sd( )sd( ))</formula><p>where sd( ) = E X,Y (Yh(X, )) 2 . Define the weighted correlation as:</p><formula xml:id="formula_31">ρ = E E (ρ( , )sd( )sd( ))/(E sd( )) 2 (14) Then PE * ( forest) = ρ(E sd( )) 2 ≤ ρPE * (tree). ✷</formula><p>Theorem (11.2) pinpoints the requirements for accurate regression forests-low correlation between residuals and low error trees. The random forest decreases the average error of the trees employed by the factor ρ. The randomization employed needs to aim at low correlation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12.">Empirical results in regression</head><p>In regression forests we use random feature selection on top of bagging. Therefore, we can use the monitoring provided by out-of-bag estimation to give estimates of PE * (forest), PE * (tree) and ρ. These are derived similarly to the estimates in classification. Throughout, features formed by a random linear sum of two inputs are used. We comment later on how many of these features to use to determine the split at each node. The more features used, the lower PE * (tree) but the higher ρ. In our empirical study the following data sets are used, see Table <ref type="table" target="#tab_4">5</ref>.</p><p>Of these data sets, the Boston Housing, Abalone and Servo are available at the UCI repository. The Robot Arm data was provided by Michael Jordan. The last three data sets are synthetic. They originated in Friedman (1991) and are also described in <ref type="bibr" target="#b6">Breiman (1998b)</ref>. These are the same data sets used to compare adaptive bagging to bagging (see <ref type="bibr" target="#b7">Breiman, 1999)</ref>, except that one synthetic data set (Peak20), which was found anomalous both by other researchers and myself, is eliminated.</p><p>The first three data sets listed are moderate in size and test set error was estimated by leaving out a random 10% of the instances, running on the remaining 90% and using the left-out 10% as a test set. This was repeated 100 times and the test set errors averaged. The abalone data set is larger with 4,177 instances and 8 input variables. It originally came with 25% of the instances set aside as a test set. We ran this data set leaving out a randomly selected 25% of the instances to use as a test set, repeated this 10 times and averaged.</p><p>Table <ref type="table" target="#tab_5">6</ref> gives the test set mean-squared error for bagging, adaptive bagging and the random forest. These were all run using 25 features, each a random linear combination of two randomly selected inputs, to split each node, each feature a random combination of two inputs. All runs with all data sets, combined 100 trees. In all data sets, the rule "don't split if the node size is &lt;5" was enforced.</p><p>An interesting difference between regression and classification is that the correlation increases quite slowly as the number of features used increases. The major effect is the decrease in PE * (tree). Therefore, a relatively large number of features are required to reduce PE * (tree) and get near optimal testset error. The results shown in Table <ref type="table" target="#tab_5">6</ref> are mixed. Random forest-random features is always better than bagging. In data sets for which adaptive bagging gives sharp decreases in error, the decreases produced by forests are not as pronounced. In data sets in which adaptive bagging gives no improvements over bagging, forests produce improvements.</p><p>For the same number of inputs combined, over a wide range, the error does not change much with the number of features. If the number used is too small, PE * (tree) becomes too large and the error goes up. If the number used is too large, the correlation goes up and the error again increases. The in-between range is usually large. In this range, as the number of features goes up, the correlation increases, but PE * (tree) compensates by decreasing.</p><p>Table <ref type="table" target="#tab_6">7</ref> gives the test set errors, the out-of-bag error estimates, and the OB estimates for PE * (tree) and the correlation.</p><p>As expected, the OB Error estimates are consistently high. It is low in the robot arm data, but I believe that this is an artifact caused by separate training and test sets, where the test set may have a slightly higher error rate than the training set.</p><p>As an experiment, I turned off the bagging and replaced it by randomizing outputs <ref type="bibr" target="#b6">(Breiman, 1998b)</ref>. In this procedure, mean-zero Gaussian noise is added to each of the outputs. The standard deviation of the noise is set equal to the standard deviation of the outputs. Similar to the bagging experiments, tree construction was done using 25 features, each a random linear combination of two randomly selected inputs, to split each node. The results are given in Table <ref type="table" target="#tab_7">8</ref>.</p><p>The error rates on the first two data sets are the lowest to date. Overall, adding output noise works with random feature selection better than bagging. This is illustrative of the flexibility of the random forest setting-various combinations of randomness can be added to see what works the best.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="13.">Remarks and conclusions</head><p>Random forests are an effective tool in prediction. Because of the Law of Large Numbers they do not overfit. Injecting the right kind of randomness makes them accurate classifiers and regressors. Furthermore, the framework in terms of strength of the individual predictors and their correlations gives insight into the ability of the random forest to predict. Using out-of-bag estimation makes concrete the otherwise theoretical values of strength and correlation.</p><p>For a while, the conventional thinking was that forests could not compete with arcing type algorithms in terms of accuracy. Our results dispel this belief, but lead to interesting questions. Boosting and arcing algorithms have the ability to reduce bias as well as variance <ref type="bibr" target="#b14">(Schapire et al., 1998)</ref>. The adaptive bagging algorithm in regression <ref type="bibr" target="#b7">(Breiman, 1999)</ref> was designed to reduce bias and operates effectively in classification as well as in regression. But, like arcing, it also changes the training set as it progresses.</p><p>Forests give results competitive with boosting and adaptive bagging, yet do not progressively change the training set. Their accuracy indicates that they act to reduce bias. The mechanism for this is not obvious. Random forests may also be viewed as a Bayesian procedure. Although I doubt that this is a fruitful line of exploration, if it could explain the bias reduction, I might become more of a Bayesian.</p><p>Random inputs and random features produce good results in classification-less so in regression. The only types of randomness used in this study is bagging and random features. It may well be that other types of injected randomness give better results. For instance, one of the referees has suggested use of random Boolean combinations of features.</p><p>After the kth classifier is constructed, Q(x, j) is computed, and used to compute ĵ(x, y) for every example in the training set. Then, let p 1 be the average over all (y, x) in the training set but not in the kth bagged training set of I (h(x, k ) = y). Then p 2 is the similar average of I (h(x, k ) = ĵ(x, y)). Substitute these estimates into (A2) to get an estimate of sd( k ). Average the sd( k ) over all k to get the final estimate of sd( ).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Effect of number of inputs on sonar data.</figDesc><graphic coords="13,110.86,171.36,372.00,465.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Effect of number of features on satellite data.</figDesc><graphic coords="15,125.36,162.05,343.20,484.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Measure of variable importance-diabetes data.</figDesc><graphic coords="20,122.36,148.75,349.00,149.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Measure of variable importance-diabetes data.</figDesc><graphic coords="21,119.65,149.26,354.46,148.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Measure of variable importance-votes data.</figDesc><graphic coords="21,127.57,335.68,339.47,140.90" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Data set summary.</figDesc><table><row><cell>Data set</cell><cell>Train size</cell><cell>Test size</cell><cell>Inputs</cell><cell>Classes</cell></row><row><cell>Glass</cell><cell>214</cell><cell>-</cell><cell>9</cell><cell></cell></row><row><cell>Breast cancer</cell><cell>699</cell><cell>-</cell><cell>9</cell><cell></cell></row><row><cell>Diabetes</cell><cell>768</cell><cell>-</cell><cell>8</cell><cell></cell></row><row><cell>Sonar</cell><cell>208</cell><cell>-</cell><cell>60</cell><cell></cell></row><row><cell>Vowel</cell><cell>990</cell><cell>-</cell><cell>10</cell><cell>11</cell></row><row><cell>Ionosphere</cell><cell>351</cell><cell>-</cell><cell>34</cell><cell></cell></row><row><cell>Vehicle</cell><cell>846</cell><cell>-</cell><cell>18</cell><cell></cell></row><row><cell>Soybean</cell><cell>685</cell><cell>-</cell><cell>35</cell><cell>19</cell></row><row><cell>German credit</cell><cell>1000</cell><cell>-</cell><cell>24</cell><cell></cell></row><row><cell>Image</cell><cell>2310</cell><cell>-</cell><cell>19</cell><cell></cell></row><row><cell>Ecoli</cell><cell>336</cell><cell>-</cell><cell>7</cell><cell></cell></row><row><cell>Votes</cell><cell>435</cell><cell>-</cell><cell>16</cell><cell></cell></row><row><cell>Liver</cell><cell>345</cell><cell>-</cell><cell>6</cell><cell></cell></row><row><cell>Letters</cell><cell>15000</cell><cell>5000</cell><cell>16</cell><cell>26</cell></row><row><cell>Sat-images</cell><cell>4435</cell><cell>2000</cell><cell>36</cell><cell></cell></row><row><cell>Zip-code</cell><cell>7291</cell><cell>2007</cell><cell>256</cell><cell>10</cell></row><row><cell>Waveform</cell><cell>300</cell><cell>3000</cell><cell>21</cell><cell></cell></row><row><cell>Twonorm</cell><cell>300</cell><cell>3000</cell><cell>20</cell><cell></cell></row><row><cell>Threenorm</cell><cell>300</cell><cell>3000</cell><cell>20</cell><cell></cell></row><row><cell>Ringnorm</cell><cell>300</cell><cell>3000</cell><cell>20</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Test set errors (%).</figDesc><table><row><cell>Data set</cell><cell>Adaboost</cell><cell>Selection</cell><cell>Forest-RI single input</cell><cell>One tree</cell></row><row><cell>Glass</cell><cell>22.0</cell><cell>20.6</cell><cell>21.2</cell><cell>36.9</cell></row><row><cell>Breast cancer</cell><cell>3.2</cell><cell>2.9</cell><cell>2.7</cell><cell>6.3</cell></row><row><cell>Diabetes</cell><cell>26.6</cell><cell>24.2</cell><cell>24.3</cell><cell>33.1</cell></row><row><cell>Sonar</cell><cell>15.6</cell><cell>15.9</cell><cell>18.0</cell><cell>31.7</cell></row><row><cell>Vowel</cell><cell>4.1</cell><cell>3.4</cell><cell>3.3</cell><cell>30.4</cell></row><row><cell>Ionosphere</cell><cell>6.4</cell><cell>7.1</cell><cell>7.5</cell><cell>12.7</cell></row><row><cell>Vehicle</cell><cell>23.2</cell><cell>25.8</cell><cell>26.4</cell><cell>33.1</cell></row><row><cell>German credit</cell><cell>23.5</cell><cell>24.4</cell><cell>26.2</cell><cell>33.3</cell></row><row><cell>Image</cell><cell>1.6</cell><cell>2.1</cell><cell>2.7</cell><cell>6.4</cell></row><row><cell>Ecoli</cell><cell>14.8</cell><cell>12.8</cell><cell>13.0</cell><cell>24.5</cell></row><row><cell>Votes</cell><cell>4.8</cell><cell>4.1</cell><cell>4.6</cell><cell>7.4</cell></row><row><cell>Liver</cell><cell>30.7</cell><cell>25.1</cell><cell>24.7</cell><cell>40.6</cell></row><row><cell>Letters</cell><cell>3.4</cell><cell>3.5</cell><cell>4.7</cell><cell>19.8</cell></row><row><cell>Sat-images</cell><cell>8.8</cell><cell>8.6</cell><cell>10.5</cell><cell>17.2</cell></row><row><cell>Zip-code</cell><cell>6.2</cell><cell>6.3</cell><cell>7.8</cell><cell>20.6</cell></row><row><cell>Waveform</cell><cell>17.8</cell><cell>17.2</cell><cell>17.3</cell><cell>34.0</cell></row><row><cell>Twonorm</cell><cell>4.9</cell><cell>3.9</cell><cell>3.9</cell><cell>24.7</cell></row><row><cell>Threenorm</cell><cell>18.8</cell><cell>17.5</cell><cell>17.5</cell><cell>38.4</cell></row><row><cell>Ringnorm</cell><cell>6.9</cell><cell>4.9</cell><cell>4.9</cell><cell>25.7</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 .</head><label>3</label><figDesc>Test set errors (%).</figDesc><table><row><cell>Forest-RC</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 .</head><label>4</label><figDesc>Increases in error rates due to noise (%).</figDesc><table><row><cell>Data set</cell><cell>Adaboost</cell><cell>Forest-RI</cell><cell>Forest-RC</cell></row><row><cell>Glass</cell><cell>1.6</cell><cell>.4</cell><cell>-.4</cell></row><row><cell>Breast cancer</cell><cell>43.2</cell><cell>1.8</cell><cell>11.1</cell></row><row><cell>Diabetes</cell><cell>6.8</cell><cell>1.7</cell><cell>2.8</cell></row><row><cell>Sonar</cell><cell>15.1</cell><cell>-6.6</cell><cell>4.2</cell></row><row><cell>Ionosphere</cell><cell>27.7</cell><cell>3.8</cell><cell>5.7</cell></row><row><cell>Soybean</cell><cell>26.9</cell><cell>3.2</cell><cell>8.5</cell></row><row><cell>Ecoli</cell><cell>7.5</cell><cell>7.9</cell><cell>7.8</cell></row><row><cell>Votes</cell><cell>48.9</cell><cell>6.3</cell><cell>4.6</cell></row><row><cell>Liver</cell><cell>10.3</cell><cell>-.2</cell><cell>4.8</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 .</head><label>5</label><figDesc>Data set summary.</figDesc><table><row><cell>Data set</cell><cell>Nr. inputs</cell><cell>#Training</cell><cell>#Test</cell></row><row><cell>Boston Housing</cell><cell>12</cell><cell>506</cell><cell>10%</cell></row><row><cell>Ozone</cell><cell>8</cell><cell>330</cell><cell>10%</cell></row><row><cell>Servo</cell><cell>4</cell><cell>167</cell><cell>10%</cell></row><row><cell>Abalone</cell><cell>8</cell><cell>4177</cell><cell>25%</cell></row><row><cell>Robot Arm</cell><cell>12</cell><cell>15,000</cell><cell>5000</cell></row><row><cell>Friedman#1</cell><cell>10</cell><cell>200</cell><cell>2000</cell></row><row><cell>Friedman#2</cell><cell>4</cell><cell>200</cell><cell>2000</cell></row><row><cell>Friedman#3</cell><cell>4</cell><cell>200</cell><cell>2000</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 .</head><label>6</label><figDesc>Mean-squared test set error.</figDesc><table><row><cell>Data set</cell><cell>Bagging</cell><cell>Adapt. bag</cell><cell>Forest</cell></row><row><cell>Boston Housing</cell><cell>11.4</cell><cell>9.7</cell><cell>10.2</cell></row><row><cell>Ozone</cell><cell>17.8</cell><cell>17.8</cell><cell>16.3</cell></row><row><cell>Servo × 10 -2</cell><cell>24.5</cell><cell>25.1</cell><cell>24.6</cell></row><row><cell>Abalone</cell><cell>4.9</cell><cell>4.9</cell><cell>4.6</cell></row><row><cell>Robot Arm × 10 -2</cell><cell>4.7</cell><cell>2.8</cell><cell>4.2</cell></row><row><cell>Friedman #1</cell><cell>6.3</cell><cell>4.1</cell><cell>5.7</cell></row><row><cell>Friedman #2 × 10 + 3</cell><cell>21.5</cell><cell>21.5</cell><cell>19.6</cell></row><row><cell>Friedman #3 × 10 -3</cell><cell>24.8</cell><cell>24.8</cell><cell>21.6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 7 .</head><label>7</label><figDesc>Error and OB estimates.</figDesc><table><row><cell>Data Set</cell><cell>Test error</cell><cell>OB error</cell><cell>PE  *  (tree)</cell><cell>Cor.</cell></row><row><cell>Boston Housing</cell><cell>10.2</cell><cell>11.6</cell><cell>26.3</cell><cell>.45</cell></row><row><cell>Ozone</cell><cell>16.3</cell><cell>17.6</cell><cell>32.5</cell><cell>.55</cell></row><row><cell>Servo ×10 -2</cell><cell>24.6</cell><cell>27.9</cell><cell>56.4</cell><cell>.56</cell></row><row><cell>Abalone</cell><cell>4.6</cell><cell>4.6</cell><cell>8.3</cell><cell>.56</cell></row><row><cell>Robot Arm ×10 -2</cell><cell>4.2</cell><cell>3.7</cell><cell>9.1</cell><cell>.41</cell></row><row><cell>Friedman #1</cell><cell>5.7</cell><cell>6.3</cell><cell>15.3</cell><cell>.41</cell></row><row><cell>Friedman #2 × 10 + 3</cell><cell>19.6</cell><cell>20.4</cell><cell>40.7</cell><cell>.51</cell></row><row><cell>Friedman #3 × 10 -3</cell><cell>21.6</cell><cell>22.9</cell><cell>48.3</cell><cell>.49</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 8 .</head><label>8</label><figDesc>Mean-squared test set error.</figDesc><table><row><cell>Data set</cell><cell>With bagging</cell><cell>With Noise</cell></row><row><cell>Boston Housing</cell><cell>10.2</cell><cell>9.1</cell></row><row><cell>Ozone</cell><cell>17.8</cell><cell>16.3</cell></row><row><cell>Servo ×10 -2</cell><cell>24.6</cell><cell>23.2</cell></row><row><cell>Abalone</cell><cell>4.6</cell><cell>4.7</cell></row><row><cell>Robot Arm ×10 -2</cell><cell>4.2</cell><cell>3.9</cell></row><row><cell>Friedman #1</cell><cell>5.7</cell><cell>5.1</cell></row><row><cell>Friedman #2 × 10 + 3</cell><cell>19.6</cell><cell>20.4</cell></row><row><cell>Friedman #3 × 10 -3</cell><cell>21.6</cell><cell>19.8</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L. BREIMAN</head><p>An almost obvious question is whether gains in accuracy can be gotten by combining random features with boosting. For the larger data sets, it seems that significantly lower error rates are possible. On some runs, we got errors as low as 5.1% on the zip-code data, 2.2% on the letters data and 7.9% on the satellite data. The improvement was less on the smaller data sets. More work is needed on this; but it does suggest that different injections of randomness can produce better results.</p><p>A recent paper <ref type="bibr" target="#b8">(Breiman, 2000)</ref> shows that in distribution space for two class problems, random forests are equivalent to a kernel acting on the true margin. Arguments are given that randomness (low correlation) enforces the symmetry of the kernel while strength enhances a desirable skewness at abrupt curved boundaries. Hopefully, this sheds light on the dual role of correlation and strength. The theoretical framework given by <ref type="bibr" target="#b13">Kleinberg (2000)</ref> for Stochastic Discrimination may also help understanding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix I: Almost sure convergence</head><p>Proof of theorem 1.2: It suffices to show that there is a set of probability zero C on the sequence space 1 , 2 , . . . such that outside of C, for all x,</p><p>For a fixed training set and fixed , the set of all x such that h( , x) = j is a union of hyper-rectangles. For all h( , x) there is only a finite number K of such unions of hyperrectangles, denoted by S 1 , . . . , S K . Define ϕ( )</p><p>By the Law of Large Numbers,</p><p>Taking unions of all the sets on which convergence does not occur for some value of k gives a set C of zero probability such that outside of C,</p><p>The right hand side is P (h( , x) = j. ✷ Proof of theorem 9.1: There are a finite set of hyper-rectangles R 1 , . . . , R K , such that if ȳk is the average of the training sets y-values for all training input vectors in R k then h( , x) has one of the values I (x ∈ S k ) ȳk . The rest of the proof parallels that of Theorem 1.2. ✷</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix II: Out-of bag estimates for strength and correlation</head><p>At the end of a combination run, let</p><p>Thus, Q(x, j) is the out-of-bag proportion of votes cast at x for class j, and is an estimate for P (h(x, ) = j). From Definition 2.1 the strength is the expectation of</p><p>Substituting Q(x, j), Q(x, y) for P (h(x, ) = j), P (h(x, ) = y) in this latter expression and taking the average over the training set gives the strength estimate. From Eq. ( <ref type="formula">7</ref>),</p><p>The variance of mr is</p><p>where s is the strength. Replacing the first term in (A1) by the average over the training set of (Q(x, y)max</p><p>and s by the out-of-bag estimate of s gives the estimate of var(mr). The standard deviation is given by</p><p>where</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Shape quantization and recognition with randomized trees</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Amit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Geman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1545" to="1588" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multiple randomized classifiers: MRCL Technical Report</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Amit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Blanchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wilder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Department of Statistics</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>University of Chicago</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An empirical comparison of voting classification algorithms</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kohavi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1/2</biblScope>
			<biblScope unit="page" from="105" to="139" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Bagging predictors</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="123" to="140" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<ptr target="ftp.stat.berkeley.edu/pub/users/breiman/OOBestimation.ps" />
		<title level="m">Out-of-bag estimation</title>
		<imprint>
			<date type="published" when="1996">1996b</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Arcing classifiers (discussion paper)</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="801" to="824" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Randomizing outputs to increase prediction accuracy</title>
		<author>
			<persName><forename type="middle">L</forename><surname>Breiman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-05-01">1998b. May 1, 1998</date>
			<biblScope unit="volume">518</biblScope>
		</imprint>
		<respStmt>
			<orgName>Statistics Department, UCB</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>in press, Machine Learning</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Using adaptive bagging to debias regressions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<idno>547</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Statistics Dept</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Some infinity theory for predictor ensembles</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<idno>579</idno>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
		<respStmt>
			<orgName>Statistics Dept. UCB</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An experimental comparison of three methods for constructing ensembles of decision trees: Bagging, boosting and randomization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dietterich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="page" from="1" to="22" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Experiments with a new boosting algorithm</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schapire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning: Proceedings of the Thirteenth International Conference</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="148" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Boosting in the limit: Maximizing the margin of learned ensembles</title>
		<author>
			<persName><forename type="first">A</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schuurmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth National Conference on Artificial Intelligence (AAAI-98)</title>
		<meeting>the Fifteenth National Conference on Artificial Intelligence (AAAI-98)</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The random subspace method for constructing decision forests</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">K</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="832" to="844" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the algorithmic implementation of stochastic discrimination</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="473" to="490" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Boosting the margin: A new explanation for the effectiveness of voting methods</title>
		<author>
			<persName><forename type="first">R</forename><surname>Schapire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1651" to="1686" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Bias, variance, and prediction error for classification rules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tibshirani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Statistics Department, University of Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An efficient method to estimate Bagging&apos;s generalization error</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Wolpert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Macready</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning)</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
